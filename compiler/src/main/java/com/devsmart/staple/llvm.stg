
stringliteral(name, str, size) ::= "@.<name> = private unnamed_addr constant [<size> x i8] c\"<str>\""

functiondecl(name, returntype, isglobal, formals, instructions) ::= <<
define <returntype> <if(isglobal)>@<endif><name>(<formals; separator=", ">) {
  <instructions; separator="\n"> 
}
>>

externfunctiondecl(name, returntype, formals) ::= <<
declare <returntype> @<name>(<formals; separator=", ">)
>>

getpointer(result, type, obj, indices) ::= <<
<result> = getelementptr <type>* <obj>, <indices; separator=", ">
>>

label(name) ::= "<name>:"
branch(condition, positive, negitive) ::= "br i1 <condition>, label <positive>, label <negitive>"
intcompare(result, operation, type, left, right) ::= "<result> = icmp <operation> <type> <left>, <right>"
equalOperator() ::= "eq"
notEqualOperator() ::= "ne"

int32type() ::= "i32"
localid(name) ::= "%<name>"
globalid(name) ::= "@<name>"

intliteral(value) ::= "<value>"

allocvar(name, type, num) ::= "<name> = alloca <type><if(num)>, <num><endif>"
load(src, dest, type) ::= "<dest> = load <type>* <src>"
store(src, dest, type) ::= "store <type> <src>, <type>* <dest>"
return(result, type) ::= "ret <type> <result>"
add(result, left, right, type) ::= "<result> = add <type> <left>, <right>;"
multiply(result, left, right, type) ::= "<result> = mul <type> <left>, <right>;"
subtract(result, left, right, type) ::= "<result> = sub <type> <left>, <right>;"
divide(result, left, right, type) ::= "<result> = sdiv <type> <left>, <right>;"
call(result, name, type, args) ::= <<
<if(type)><result> = <endif>call <type> <name>(<args; separator=", ">)
>>